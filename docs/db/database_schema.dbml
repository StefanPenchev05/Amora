enum account_status {
  active
  deactivated
  suspended
}

enum genders {
  female
  male
  something_else
  prefer_not_to_say
}

enum invite_status {
  sent
  accepted
  declined
  expired
}

enum relationship_status {
  active
  paused
  ended
}

enum event_category {
  lecture
  appointment
  date
  travel
  celebration
  health
  chore
  occupied
  other
}

enum reminder_unit { 
  minutes 
  hours 
  days 
}

enum post_status {
  published
  archived
  deleted
}

enum visibility_level {
  private 
  friends 
  public 
}

enum reaction_type { 
  like 
  love 
  laugh  
  sad 
}

enum media_kind {
  image
  video 
  audio 
  file 
}


Table Users {
  id          uuid       [pk]
  created_at  timestamp  [not null, default: `now()`]
  updated_at  timestamp  [not null, default: `now()`]
  status      account_status [not null, default: 'active']
}

Table Credentials {
  user_id        uuid      [pk, not null, ref: - Users.id]
  email          varchar   [not null, unique]
  password       varchar   [not null, note: "It will be hashed"]
  username       varchar   [not null, unique]
  email_verified boolean   [not null, default: false]
  mfa_enabled    boolean   [not null, default: false]
  mfa_secret     varchar   [default: null]
  last_login_at  timestamp [default: null]                  
}

Table Profile {
  user_id          uuid      [pk, not null, ref: - Users.id] 
  first_name       varchar
  last_name        varchar
  gender           genders   [not null, default: 'prefer_not_to_say']
  date_of_birth    date
  bio              varchar
  display_name     varchar
  avatar_photo_id  varchar   
  relationship     uuid      [ref: < Relationship.id]
  locale           varchar   [not null, default: 'en']
  timezone         varchar   [not null, default: 'UTC']
}

Table Sessions {
  id             uuid       [pk]
  user_id        uuid       [not null, ref: > Users.id]
  user_agent     varchar
  ip_address     varchar
  created_at     timestamp  [not null, default: `now()`]
  last_used_at   timestamp  [not null, default: `now()`]
  revoked_at     timestamp
  token_version  int        [not null, default: 0]

  Indexes {
    (user_id, last_used_at) [name: 'idx_sessions_user_active']      // Better for finding active sessions
    (user_id, revoked_at)   [name: 'idx_sessions_user_revoked']     // Quick lookup for valid sessions
    last_used_at            [name: 'idx_sessions_cleanup']          // For session cleanup jobs
  }
}

Table Refresh_Tokens {
  id          uuid      [pk]                       
  session_id  uuid      [not null, ref: > Sessions.id]
  jti         uuid      [not null, unique]         
  family_id   uuid      [not null]                 
  token_hash  varchar   [not null]
  expires_at  timestamp [not null]
  created_at  timestamp [not null, default: `now()`]
  rotated_at  timestamp
  revoked_at  timestamp
  reason      varchar
}

Table RelationshipInvites {
  id            uuid        [pk, not null]
  inviter_id    uuid        [not null, ref: > Users.id]
  invitee_id    uuid        [not null, ref: > Users.id]
  status        invite_status [not null, default: 'sent']
  message       varchar
  created_at    timestamp   [not null, default: `now()`]
  responded_at  timestamp

  Indexes {
    (invitee_id, status, created_at) [name: 'idx_relinv_by_invitee_status_created']  // More selective with timestamp
    (inviter_id, invitee_id)         [name: 'idx_relinv_pair', unique]        // Prevent duplicate invites
    (status, created_at)             [name: 'idx_relinv_status_created']            // For admin queries
  }
}

Table Relationship {
  id               uuid      [pk, not null, note: "Use UUID for easier sharding and links"]
  partner_a_id     uuid      [not null, ref: - Users.id, note: "Enforce a != b and a < b in SQL"]
  partner_b_id     uuid      [not null, ref: - Users.id, note: "Enforce a != b and a < b in SQL"]

  status           relationship_status [not null, default: 'active']
  visibility       visibility_level    [not null, default: 'private']

  title            varchar
  slug             varchar   [unique, note: "Pretty URL (optional)"]

  started_at       timestamp [not null, default: `now()`]
  anniversary_at   date
  ended_at         timestamp

  avatar_photo_id  uuid      // ref > Photos.id when I add Photos
  banner_photo_id  uuid

  created_by       uuid      [ref: > Users.id]
  created_at       timestamp [not null, default: `now()`]
  updated_at       timestamp [not null, default: `now()`]
  last_activity_at timestamp

  posts_count     int [not null, default: 0, note: "Must be >= 0"]
  notes_count     int [not null, default: 0, note: "Must be >= 0"]
  photos_count    int [not null, default: 0, note: "Must be >= 0"]

  deleted_at      timestamp
}

Table CalendarEvents {
  id uuid [pk, not null]
  relationship_id uuid [not null, ref: > Relationship.id]

  title varchar [not null]
  description varchar 
  category event_category [not null, default: `other`]

  start_at timestamp [not null]
  end_at timestamp [not null]
  all_day boolean [not null, default: false]
  timezone varchar [not null, default: 'UTC']

  location varchar
  color varchar 

  rrule            varchar   [note: "RFC 5545 RRULE, e.g., FREQ=WEEKLY;BYDAY=MO;COUNT=12"]
  rrule_until      timestamp
  rrule_exdates    json      [note: "ISO dates excluded (list)"]

  created_at       timestamp [not null, default: `now()`]
  updated_at       timestamp [not null, default: `now()`]

  // Note: Add these constraints in SQL migration:
  // - end_at >= start_at
  // - rrule_until IS NULL OR rrule_until >= start_at

  Indexes {
    (relationship_id, start_at, end_at)    [name: 'idx_events_relationship_timerange']  // Better for range queries
    (relationship_id, category, start_at)  [name: 'idx_events_relationship_category']   // Category filtering with time
    (start_at, end_at)                     [name: 'idx_events_global_timerange']       // Cross-relationship queries
  }
}

Table CalendarIntegrations {
  id               uuid [pk]
  relationship_id  uuid [not null, ref: > Relationship.id]
  user_id          uuid [not null, ref: > Users.id]
  provider         varchar   [not null]         // 'google', 'apple', 'ics'
  external_calendar_id varchar [not null]
  sync_cursor      varchar
  active           boolean [not null, default: true]
  connected_at     timestamp [not null, default: `now()`]
  updated_at       timestamp [not null, default: `now()`]

  Indexes { 
    (relationship_id, provider) 
    (user_id, provider)
  }
}

Table WallPost {
  id               uuid      [pk]
  relationship_id  uuid      [not null, ref: > Relationship.id]
  author_user_id   uuid      [not null, ref: > Users.id]
  status           post_status [not null, default: 'published']

  title            varchar
  body             text
  memory_date      date       [note: "When the memory happened (backdating)"]
  location_name    varchar
  latitude         numeric(9,6)
  longitude        numeric(9,6)

  visibility       visibility_level [not null, default: 'private']
  pinned           boolean   [not null, default: false]
  allow_comments   boolean   [not null, default: true]

  created_at       timestamp [not null, default: `now()`]
  updated_at       timestamp [not null, default: `now()`]

  comments_count   int [not null, default: 0]
  reactions_count  int [not null, default: 0]

  Indexes {
    (relationship_id, status, created_at)    [name: 'idx_posts_relationship_status']     // Filter published posts
    (relationship_id, pinned, created_at)    [name: 'idx_posts_relationship_pinned']     // Pinned posts first
    (relationship_id, memory_date)           [name: 'idx_posts_relationship_memory']     // Memory timeline
    (author_user_id, created_at)             [name: 'idx_posts_author']                  // User's posts
  }
}

Table WallPostMedia {
  id               uuid [pk]
  post_id          uuid [not null, ref: > WallPost.id]
  kind             media_kind [not null, default: 'image']
  storage_key      varchar [not null]
  mime_type        varchar  [not null]
  width            int [note: "Must be > 0 if not null"]
  height           int [note: "Must be > 0 if not null"]
  duration_sec     int [note: "Must be >= 0 if not null"]
  position         int  [not null, default: 0, note: "Must be >= 0"]
  created_at       timestamp [not null, default: `now()`]

  Indexes { (post_id, position) }
}

Table WallPostMention {
  id               uuid [pk]
  post_id          uuid [not null, ref: > WallPost.id]
  mentioned_user_id uuid [not null, ref: > Users.id]
  Indexes { (post_id, mentioned_user_id) }
}

Table WallReaction {
  post_id          uuid [not null, ref: > WallPost.id]
  user_id          uuid [not null, ref: > Users.id]
  type             reaction_type [not null, default: 'like']
  created_at       timestamp [not null, default: `now()`]

  Indexes {
    (post_id, user_id) [pk]
    (post_id, type)
  }
}

Table WallComment {
  id               uuid [pk]
  post_id          uuid [not null, ref: > WallPost.id]
  author_user_id   uuid [not null, ref: > Users.id]
  parent_id        uuid [ref: > WallComment.id]
  body             text   [not null]
  created_at       timestamp [not null, default: `now()`]
  updated_at       timestamp [not null, default: `now()`]
  deleted_at       timestamp

  Indexes {
    (post_id, created_at)
    parent_id
  }
}

Table CoupleNote {
  id               uuid      [pk]
  relationship_id  uuid      [not null, ref: > Relationship.id]
  author_user_id   uuid      [not null, ref: > Users.id]

  title            varchar
  pinned           boolean   [not null, default: false]

  color            varchar   [note: "UI accent hex (optional)"]
  last_edited_by   uuid      [ref: > Users.id]
  created_at       timestamp [not null, default: `now()`]
  updated_at       timestamp [not null, default: `now()`]

  Indexes {
    (relationship_id, pinned)
    (relationship_id, updated_at)
    (relationship_id)
  }
}

Table MoodCheck {
  id               uuid      [pk]
  relationship_id  uuid      [not null, ref: > Relationship.id]
  user_id          uuid      [not null, ref: > Users.id]

  score            int       [not null, note: "1-5 range (1=very low, 5=very high). Add CHECK constraint in SQL"]
  note             varchar   
  created_at       timestamp [not null, default: `now()`]

  Indexes {
    (relationship_id, created_at)                [name: 'idx_mood_relationship_time']    // Mood timeline
    (user_id, created_at)                        [name: 'idx_mood_user_time']            // User's mood history  
    (relationship_id, user_id, created_at)       [name: 'idx_mood_user_relationship']    // Specific user in relationship
    (created_at)                                 [name: 'idx_mood_global_time']          // Global mood trends
  }
}
